"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/form-data-encoder";
exports.ids = ["vendor-chunks/form-data-encoder"];
exports.modules = {

/***/ "(rsc)/./node_modules/form-data-encoder/lib/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/index.cjs ***!
  \******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  FormDataEncoder: () => FormDataEncoder,\n  isFile: () => isFile,\n  isFormData: () => isFormData\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/util/chunk.ts\nvar MAX_CHUNK_SIZE = 65536;\nfunction* chunk(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\n\n// src/util/createBoundary.ts\nvar alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nfunction createBoundary() {\n  let size = 16;\n  let res = \"\";\n  while (size--) {\n    res += alphabet[Math.random() * alphabet.length << 0];\n  }\n  return res;\n}\n\n// src/util/escapeName.ts\nvar escapeName = (name) => String(name).replace(/\\r/g, \"%0D\").replace(/\\n/g, \"%0A\").replace(/\"/g, \"%22\");\n\n// src/util/isFunction.ts\nvar isFunction = (value) => typeof value === \"function\";\n\n// src/util/isReadableStreamFallback.ts\nvar isReadableStreamFallback = (value) => !!value && typeof value === \"object\" && !Array.isArray(value) && isFunction(value.getReader);\n\n// src/util/isAsyncIterable.ts\nvar isAsyncIterable = (value) => isFunction(value[Symbol.asyncIterator]);\n\n// src/util/getStreamIterator.ts\nasync function* readStream(readable) {\n  const reader = readable.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function* chunkStream(stream) {\n  for await (const value of stream) {\n    yield* chunk(value);\n  }\n}\nvar getStreamIterator = (source) => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isReadableStreamFallback(source)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\n    \"Unsupported data source: Expected either ReadableStream or async iterable.\"\n  );\n};\n\n// src/util/isFile.ts\nvar isFile = (value) => Boolean(\n  value && typeof value === \"object\" && isFunction(value.constructor) && value[Symbol.toStringTag] === \"File\" && isFunction(value.stream) && value.name != null\n);\n\n// src/util/isFormData.ts\nvar isFormData = (value) => Boolean(\n  value && isFunction(value.constructor) && value[Symbol.toStringTag] === \"FormData\" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator])\n);\n\n// src/util/isPlainObject.ts\nvar getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\nfunction isPlainObject(value) {\n  if (getType(value) !== \"object\") {\n    return false;\n  }\n  const pp = Object.getPrototypeOf(value);\n  if (pp === null || pp === void 0) {\n    return true;\n  }\n  return pp.constructor?.toString?.() === Object.toString();\n}\n\n// src/util/normalizeValue.ts\nvar normalizeValue = (value) => String(value).replace(/\\r|\\n/g, (match, i, str) => {\n  if (match === \"\\r\" && str[i + 1] !== \"\\n\" || match === \"\\n\" && str[i - 1] !== \"\\r\") {\n    return \"\\r\\n\";\n  }\n  return match;\n});\n\n// src/util/proxyHeaders.ts\nfunction getProperty(target, prop) {\n  if (typeof prop === \"string\") {\n    for (const [name, value] of Object.entries(target)) {\n      if (prop.toLowerCase() === name.toLowerCase()) {\n        return value;\n      }\n    }\n  }\n  return void 0;\n}\nvar proxyHeaders = (object) => new Proxy(\n  object,\n  {\n    get: (target, prop) => getProperty(target, prop),\n    has: (target, prop) => getProperty(target, prop) !== void 0\n  }\n);\n\n// src/FormDataEncoder.ts\nvar defaultOptions = {\n  enableAdditionalHeaders: false\n};\nvar readonlyProp = { writable: false, configurable: false };\nvar _CRLF, _CRLF_BYTES, _CRLF_BYTES_LENGTH, _DASHES, _encoder, _footer, _form, _options, _FormDataEncoder_instances, getFieldHeader_fn, getContentLength_fn;\nvar FormDataEncoder = class {\n  constructor(form, boundaryOrOptions, options) {\n    __privateAdd(this, _FormDataEncoder_instances);\n    __privateAdd(this, _CRLF, \"\\r\\n\");\n    __privateAdd(this, _CRLF_BYTES);\n    __privateAdd(this, _CRLF_BYTES_LENGTH);\n    __privateAdd(this, _DASHES, \"-\".repeat(2));\n    /**\n     * TextEncoder instance\n     */\n    __privateAdd(this, _encoder, new TextEncoder());\n    /**\n     * Returns form-data footer bytes\n     */\n    __privateAdd(this, _footer);\n    /**\n     * FormData instance\n     */\n    __privateAdd(this, _form);\n    /**\n     * Instance options\n     */\n    __privateAdd(this, _options);\n    if (!isFormData(form)) {\n      throw new TypeError(\"Expected first argument to be a FormData instance.\");\n    }\n    let boundary;\n    if (isPlainObject(boundaryOrOptions)) {\n      options = boundaryOrOptions;\n    } else {\n      boundary = boundaryOrOptions;\n    }\n    if (!boundary) {\n      boundary = `form-data-encoder-${createBoundary()}`;\n    }\n    if (typeof boundary !== \"string\") {\n      throw new TypeError(\"Expected boundary argument to be a string.\");\n    }\n    if (options && !isPlainObject(options)) {\n      throw new TypeError(\"Expected options argument to be an object.\");\n    }\n    __privateSet(this, _form, Array.from(form.entries()));\n    __privateSet(this, _options, { ...defaultOptions, ...options });\n    __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));\n    __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);\n    this.boundary = boundary;\n    this.contentType = `multipart/form-data; boundary=${this.boundary}`;\n    __privateSet(this, _footer, __privateGet(this, _encoder).encode(\n      `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`\n    ));\n    const headers = {\n      \"Content-Type\": this.contentType\n    };\n    const contentLength = __privateMethod(this, _FormDataEncoder_instances, getContentLength_fn).call(this);\n    if (contentLength) {\n      this.contentLength = contentLength;\n      headers[\"Content-Length\"] = contentLength;\n    }\n    this.headers = proxyHeaders(Object.freeze(headers));\n    Object.defineProperties(this, {\n      boundary: readonlyProp,\n      contentType: readonlyProp,\n      contentLength: readonlyProp,\n      headers: readonlyProp\n    });\n  }\n  /**\n   * Creates an iterator allowing to go through form-data parts (with metadata).\n   * This method **will not** read the files and **will not** split values big into smaller chunks.\n   *\n   * Using this method, you can convert form-data content into Blob:\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import {FormData} from \"formdata-polyfill/esm-min.js\"\n   * import {fileFrom} from \"fetch-blob/form.js\"\n   * import {File} from \"fetch-blob/file.js\"\n   * import {Blob} from \"fetch-blob\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"]))\n   * form.set(\"fileFromPath\", await fileFrom(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   body: new Blob(encoder, {type: encoder.contentType})\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  *values() {\n    for (const [name, raw] of __privateGet(this, _form)) {\n      const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n      yield __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value);\n      yield value;\n      yield __privateGet(this, _CRLF_BYTES);\n    }\n    yield __privateGet(this, _footer);\n  }\n  /**\n   * Creates an async iterator allowing to perform the encoding by portions.\n   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormData, File, fileFromPath} from \"formdata-node\"\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"], \"file.txt\"))\n   * form.set(\"fileFromPath\", await fileFromPath(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   headers: encoder.headers,\n   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  async *encode() {\n    for (const part of this.values()) {\n      if (isFile(part)) {\n        yield* getStreamIterator(part.stream());\n      } else {\n        yield* chunk(part);\n      }\n    }\n  }\n  /**\n   * Creates an iterator allowing to read through the encoder data using for...of loops\n   */\n  [Symbol.iterator]() {\n    return this.values();\n  }\n  /**\n   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops\n   */\n  [Symbol.asyncIterator]() {\n    return this.encode();\n  }\n};\n_CRLF = new WeakMap();\n_CRLF_BYTES = new WeakMap();\n_CRLF_BYTES_LENGTH = new WeakMap();\n_DASHES = new WeakMap();\n_encoder = new WeakMap();\n_footer = new WeakMap();\n_form = new WeakMap();\n_options = new WeakMap();\n_FormDataEncoder_instances = new WeakSet();\ngetFieldHeader_fn = function(name, value) {\n  let header = \"\";\n  header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;\n  header += `Content-Disposition: form-data; name=\"${escapeName(name)}\"`;\n  if (isFile(value)) {\n    header += `; filename=\"${escapeName(value.name)}\"${__privateGet(this, _CRLF)}`;\n    header += `Content-Type: ${value.type || \"application/octet-stream\"}`;\n  }\n  if (__privateGet(this, _options).enableAdditionalHeaders === true) {\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size != null && !isNaN(size)) {\n      header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;\n    }\n  }\n  return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);\n};\n/**\n * Returns form-data content length\n */\ngetContentLength_fn = function() {\n  let length = 0;\n  for (const [name, raw] of __privateGet(this, _form)) {\n    const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size == null || isNaN(size)) {\n      return void 0;\n    }\n    length += __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value).byteLength;\n    length += size;\n    length += __privateGet(this, _CRLF_BYTES_LENGTH);\n  }\n  return String(length + __privateGet(this, _footer).byteLength);\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhLWVuY29kZXIvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxjQUFjO0FBQ3RFO0FBQ0EsU0FBUyw0QkFBNEIsRUFBRSxjQUFjLEVBQUUsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCLEVBQUUsY0FBYyxFQUFFLDBCQUEwQjtBQUN2Riw2Q0FBNkMsUUFBUSxpQkFBaUI7QUFDdEU7QUFDQSxpQkFBaUIsWUFBWSx1QkFBdUIsR0FBRywwQkFBMEI7QUFDakYsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEIsa0JBQWtCLEtBQUs7QUFDcEU7QUFDQTtBQUNBLGdEQUFnRCxPQUFPLEVBQUUsb0NBQW9DO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEtZW5jb2Rlci9saWIvaW5kZXguY2pzPzcyYTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3R5cGVFcnJvciA9IChtc2cpID0+IHtcbiAgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiBtZW1iZXIuaGFzKG9iaikgfHwgX190eXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSk7XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4gbWVtYmVyLmhhcyhvYmopID8gX190eXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLCBtZXRob2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgRm9ybURhdGFFbmNvZGVyOiAoKSA9PiBGb3JtRGF0YUVuY29kZXIsXG4gIGlzRmlsZTogKCkgPT4gaXNGaWxlLFxuICBpc0Zvcm1EYXRhOiAoKSA9PiBpc0Zvcm1EYXRhXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL3V0aWwvY2h1bmsudHNcbnZhciBNQVhfQ0hVTktfU0laRSA9IDY1NTM2O1xuZnVuY3Rpb24qIGNodW5rKHZhbHVlKSB7XG4gIGlmICh2YWx1ZS5ieXRlTGVuZ3RoIDw9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgeWllbGQgdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvZmZzZXQgPSAwO1xuICB3aGlsZSAob2Zmc2V0IDwgdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0LCBNQVhfQ0hVTktfU0laRSk7XG4gICAgY29uc3QgYnVmZmVyID0gdmFsdWUuYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgb2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvY3JlYXRlQm91bmRhcnkudHNcbnZhciBhbHBoYWJldCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG5mdW5jdGlvbiBjcmVhdGVCb3VuZGFyeSgpIHtcbiAgbGV0IHNpemUgPSAxNjtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIHdoaWxlIChzaXplLS0pIHtcbiAgICByZXMgKz0gYWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCA8PCAwXTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdXRpbC9lc2NhcGVOYW1lLnRzXG52YXIgZXNjYXBlTmFtZSA9IChuYW1lKSA9PiBTdHJpbmcobmFtZSkucmVwbGFjZSgvXFxyL2csIFwiJTBEXCIpLnJlcGxhY2UoL1xcbi9nLCBcIiUwQVwiKS5yZXBsYWNlKC9cIi9nLCBcIiUyMlwiKTtcblxuLy8gc3JjL3V0aWwvaXNGdW5jdGlvbi50c1xudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4vLyBzcmMvdXRpbC9pc1JlYWRhYmxlU3RyZWFtRmFsbGJhY2sudHNcbnZhciBpc1JlYWRhYmxlU3RyZWFtRmFsbGJhY2sgPSAodmFsdWUpID0+ICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmdldFJlYWRlcik7XG5cbi8vIHNyYy91dGlsL2lzQXN5bmNJdGVyYWJsZS50c1xudmFyIGlzQXN5bmNJdGVyYWJsZSA9ICh2YWx1ZSkgPT4gaXNGdW5jdGlvbih2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pO1xuXG4vLyBzcmMvdXRpbC9nZXRTdHJlYW1JdGVyYXRvci50c1xuYXN5bmMgZnVuY3Rpb24qIHJlYWRTdHJlYW0ocmVhZGFibGUpIHtcbiAgY29uc3QgcmVhZGVyID0gcmVhZGFibGUuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHlpZWxkIHZhbHVlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiogY2h1bmtTdHJlYW0oc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtKSB7XG4gICAgeWllbGQqIGNodW5rKHZhbHVlKTtcbiAgfVxufVxudmFyIGdldFN0cmVhbUl0ZXJhdG9yID0gKHNvdXJjZSkgPT4ge1xuICBpZiAoaXNBc3luY0l0ZXJhYmxlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gY2h1bmtTdHJlYW0oc291cmNlKTtcbiAgfVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbUZhbGxiYWNrKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gY2h1bmtTdHJlYW0ocmVhZFN0cmVhbShzb3VyY2UpKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgIFwiVW5zdXBwb3J0ZWQgZGF0YSBzb3VyY2U6IEV4cGVjdGVkIGVpdGhlciBSZWFkYWJsZVN0cmVhbSBvciBhc3luYyBpdGVyYWJsZS5cIlxuICApO1xufTtcblxuLy8gc3JjL3V0aWwvaXNGaWxlLnRzXG52YXIgaXNGaWxlID0gKHZhbHVlKSA9PiBCb29sZWFuKFxuICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaXNGdW5jdGlvbih2YWx1ZS5jb25zdHJ1Y3RvcikgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJGaWxlXCIgJiYgaXNGdW5jdGlvbih2YWx1ZS5zdHJlYW0pICYmIHZhbHVlLm5hbWUgIT0gbnVsbFxuKTtcblxuLy8gc3JjL3V0aWwvaXNGb3JtRGF0YS50c1xudmFyIGlzRm9ybURhdGEgPSAodmFsdWUpID0+IEJvb2xlYW4oXG4gIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUuY29uc3RydWN0b3IpICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiRm9ybURhdGFcIiAmJiBpc0Z1bmN0aW9uKHZhbHVlLmFwcGVuZCkgJiYgaXNGdW5jdGlvbih2YWx1ZS5nZXRBbGwpICYmIGlzRnVuY3Rpb24odmFsdWUuZW50cmllcykgJiYgaXNGdW5jdGlvbih2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKVxuKTtcblxuLy8gc3JjL3V0aWwvaXNQbGFpbk9iamVjdC50c1xudmFyIGdldFR5cGUgPSAodmFsdWUpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcCA9PT0gbnVsbCB8fCBwcCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHBwLmNvbnN0cnVjdG9yPy50b1N0cmluZz8uKCkgPT09IE9iamVjdC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvdXRpbC9ub3JtYWxpemVWYWx1ZS50c1xudmFyIG5vcm1hbGl6ZVZhbHVlID0gKHZhbHVlKSA9PiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1xccnxcXG4vZywgKG1hdGNoLCBpLCBzdHIpID0+IHtcbiAgaWYgKG1hdGNoID09PSBcIlxcclwiICYmIHN0cltpICsgMV0gIT09IFwiXFxuXCIgfHwgbWF0Y2ggPT09IFwiXFxuXCIgJiYgc3RyW2kgLSAxXSAhPT0gXCJcXHJcIikge1xuICAgIHJldHVybiBcIlxcclxcblwiO1xuICB9XG4gIHJldHVybiBtYXRjaDtcbn0pO1xuXG4vLyBzcmMvdXRpbC9wcm94eUhlYWRlcnMudHNcbmZ1bmN0aW9uIGdldFByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGFyZ2V0KSkge1xuICAgICAgaWYgKHByb3AudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbnZhciBwcm94eUhlYWRlcnMgPSAob2JqZWN0KSA9PiBuZXcgUHJveHkoXG4gIG9iamVjdCxcbiAge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wKSxcbiAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IGdldFByb3BlcnR5KHRhcmdldCwgcHJvcCkgIT09IHZvaWQgMFxuICB9XG4pO1xuXG4vLyBzcmMvRm9ybURhdGFFbmNvZGVyLnRzXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuYWJsZUFkZGl0aW9uYWxIZWFkZXJzOiBmYWxzZVxufTtcbnZhciByZWFkb25seVByb3AgPSB7IHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSB9O1xudmFyIF9DUkxGLCBfQ1JMRl9CWVRFUywgX0NSTEZfQllURVNfTEVOR1RILCBfREFTSEVTLCBfZW5jb2RlciwgX2Zvb3RlciwgX2Zvcm0sIF9vcHRpb25zLCBfRm9ybURhdGFFbmNvZGVyX2luc3RhbmNlcywgZ2V0RmllbGRIZWFkZXJfZm4sIGdldENvbnRlbnRMZW5ndGhfZm47XG52YXIgRm9ybURhdGFFbmNvZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihmb3JtLCBib3VuZGFyeU9yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2luc3RhbmNlcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9DUkxGLCBcIlxcclxcblwiKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX0NSTEZfQllURVMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfQ1JMRl9CWVRFU19MRU5HVEgpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfREFTSEVTLCBcIi1cIi5yZXBlYXQoMikpO1xuICAgIC8qKlxuICAgICAqIFRleHRFbmNvZGVyIGluc3RhbmNlXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9lbmNvZGVyLCBuZXcgVGV4dEVuY29kZXIoKSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmb3JtLWRhdGEgZm9vdGVyIGJ5dGVzXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mb290ZXIpO1xuICAgIC8qKlxuICAgICAqIEZvcm1EYXRhIGluc3RhbmNlXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mb3JtKTtcbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvcHRpb25zXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vcHRpb25zKTtcbiAgICBpZiAoIWlzRm9ybURhdGEoZm9ybSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBhIEZvcm1EYXRhIGluc3RhbmNlLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kYXJ5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvdW5kYXJ5T3JPcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IGJvdW5kYXJ5T3JPcHRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyeSA9IGJvdW5kYXJ5T3JPcHRpb25zO1xuICAgIH1cbiAgICBpZiAoIWJvdW5kYXJ5KSB7XG4gICAgICBib3VuZGFyeSA9IGBmb3JtLWRhdGEtZW5jb2Rlci0ke2NyZWF0ZUJvdW5kYXJ5KCl9YDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBib3VuZGFyeSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGJvdW5kYXJ5IGFyZ3VtZW50IHRvIGJlIGEgc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgIWlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC5cIik7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZm9ybSwgQXJyYXkuZnJvbShmb3JtLmVudHJpZXMoKSkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfb3B0aW9ucywgeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX0NSTEZfQllURVMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKF9fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRikpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX0NSTEZfQllURVNfTEVOR1RILCBfX3ByaXZhdGVHZXQodGhpcywgX0NSTEZfQllURVMpLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7dGhpcy5ib3VuZGFyeX1gO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZm9vdGVyLCBfX3ByaXZhdGVHZXQodGhpcywgX2VuY29kZXIpLmVuY29kZShcbiAgICAgIGAke19fcHJpdmF0ZUdldCh0aGlzLCBfREFTSEVTKX0ke3RoaXMuYm91bmRhcnl9JHtfX3ByaXZhdGVHZXQodGhpcywgX0RBU0hFUyl9JHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpLnJlcGVhdCgyKX1gXG4gICAgKSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IHRoaXMuY29udGVudFR5cGVcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9pbnN0YW5jZXMsIGdldENvbnRlbnRMZW5ndGhfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIHRoaXMuY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBjb250ZW50TGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnMgPSBwcm94eUhlYWRlcnMoT2JqZWN0LmZyZWV6ZShoZWFkZXJzKSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgYm91bmRhcnk6IHJlYWRvbmx5UHJvcCxcbiAgICAgIGNvbnRlbnRUeXBlOiByZWFkb25seVByb3AsXG4gICAgICBjb250ZW50TGVuZ3RoOiByZWFkb25seVByb3AsXG4gICAgICBoZWFkZXJzOiByZWFkb25seVByb3BcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpdGVyYXRvciBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGZvcm0tZGF0YSBwYXJ0cyAod2l0aCBtZXRhZGF0YSkuXG4gICAqIFRoaXMgbWV0aG9kICoqd2lsbCBub3QqKiByZWFkIHRoZSBmaWxlcyBhbmQgKip3aWxsIG5vdCoqIHNwbGl0IHZhbHVlcyBiaWcgaW50byBzbWFsbGVyIGNodW5rcy5cbiAgICpcbiAgICogVXNpbmcgdGhpcyBtZXRob2QsIHlvdSBjYW4gY29udmVydCBmb3JtLWRhdGEgY29udGVudCBpbnRvIEJsb2I6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7UmVhZGFibGV9IGZyb20gXCJzdHJlYW1cIlxuICAgKlxuICAgKiBpbXBvcnQge0Zvcm1EYXRhRW5jb2Rlcn0gZnJvbSBcImZvcm0tZGF0YS1lbmNvZGVyXCJcbiAgICpcbiAgICogaW1wb3J0IHtGb3JtRGF0YX0gZnJvbSBcImZvcm1kYXRhLXBvbHlmaWxsL2VzbS1taW4uanNcIlxuICAgKiBpbXBvcnQge2ZpbGVGcm9tfSBmcm9tIFwiZmV0Y2gtYmxvYi9mb3JtLmpzXCJcbiAgICogaW1wb3J0IHtGaWxlfSBmcm9tIFwiZmV0Y2gtYmxvYi9maWxlLmpzXCJcbiAgICogaW1wb3J0IHtCbG9ifSBmcm9tIFwiZmV0Y2gtYmxvYlwiXG4gICAqXG4gICAqIGltcG9ydCBmZXRjaCBmcm9tIFwibm9kZS1mZXRjaFwiXG4gICAqXG4gICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgKlxuICAgKiBmb3JtLnNldChcImZpZWxkXCIsIFwiSnVzdCBhIHJhbmRvbSBzdHJpbmdcIilcbiAgICogZm9ybS5zZXQoXCJmaWxlXCIsIG5ldyBGaWxlKFtcIlVzaW5nIGZpbGVzIGlzIGNsYXNzIGFtYXppbmdcIl0pKVxuICAgKiBmb3JtLnNldChcImZpbGVGcm9tUGF0aFwiLCBhd2FpdCBmaWxlRnJvbShcInBhdGgvdG8vYS9maWxlLnR4dFwiKSlcbiAgICpcbiAgICogY29uc3QgZW5jb2RlciA9IG5ldyBGb3JtRGF0YUVuY29kZXIoZm9ybSlcbiAgICpcbiAgICogY29uc3Qgb3B0aW9ucyA9IHtcbiAgICogICBtZXRob2Q6IFwicG9zdFwiLFxuICAgKiAgIGJvZHk6IG5ldyBCbG9iKGVuY29kZXIsIHt0eXBlOiBlbmNvZGVyLmNvbnRlbnRUeXBlfSlcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9odHRwYmluLm9yZy9wb3N0XCIsIG9wdGlvbnMpXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcbiAgICogYGBgXG4gICAqL1xuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHJhd10gb2YgX19wcml2YXRlR2V0KHRoaXMsIF9mb3JtKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBpc0ZpbGUocmF3KSA/IHJhdyA6IF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKG5vcm1hbGl6ZVZhbHVlKHJhdykpO1xuICAgICAgeWllbGQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfaW5zdGFuY2VzLCBnZXRGaWVsZEhlYWRlcl9mbikuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIHlpZWxkIF9fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRl9CWVRFUyk7XG4gICAgfVxuICAgIHlpZWxkIF9fcHJpdmF0ZUdldCh0aGlzLCBfZm9vdGVyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luYyBpdGVyYXRvciBhbGxvd2luZyB0byBwZXJmb3JtIHRoZSBlbmNvZGluZyBieSBwb3J0aW9ucy5cbiAgICogVGhpcyBtZXRob2QgcmVhZHMgdGhyb3VnaCBmaWxlcyBhbmQgc3BsaXRzIGJpZyB2YWx1ZXMgaW50byBzbWFsbGVyIHBpZWNlcyAoNjU1MzYgYnl0ZXMgcGVyIGVhY2gpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQge1JlYWRhYmxlfSBmcm9tIFwic3RyZWFtXCJcbiAgICpcbiAgICogaW1wb3J0IHtGb3JtRGF0YSwgRmlsZSwgZmlsZUZyb21QYXRofSBmcm9tIFwiZm9ybWRhdGEtbm9kZVwiXG4gICAqIGltcG9ydCB7Rm9ybURhdGFFbmNvZGVyfSBmcm9tIFwiZm9ybS1kYXRhLWVuY29kZXJcIlxuICAgKlxuICAgKiBpbXBvcnQgZmV0Y2ggZnJvbSBcIm5vZGUtZmV0Y2hcIlxuICAgKlxuICAgKiBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICpcbiAgICogZm9ybS5zZXQoXCJmaWVsZFwiLCBcIkp1c3QgYSByYW5kb20gc3RyaW5nXCIpXG4gICAqIGZvcm0uc2V0KFwiZmlsZVwiLCBuZXcgRmlsZShbXCJVc2luZyBmaWxlcyBpcyBjbGFzcyBhbWF6aW5nXCJdLCBcImZpbGUudHh0XCIpKVxuICAgKiBmb3JtLnNldChcImZpbGVGcm9tUGF0aFwiLCBhd2FpdCBmaWxlRnJvbVBhdGgoXCJwYXRoL3RvL2EvZmlsZS50eHRcIikpXG4gICAqXG4gICAqIGNvbnN0IGVuY29kZXIgPSBuZXcgRm9ybURhdGFFbmNvZGVyKGZvcm0pXG4gICAqXG4gICAqIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAqICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICogICBoZWFkZXJzOiBlbmNvZGVyLmhlYWRlcnMsXG4gICAqICAgYm9keTogUmVhZGFibGUuZnJvbShlbmNvZGVyLmVuY29kZSgpKSAvLyBvciBSZWFkYWJsZS5mcm9tKGVuY29kZXIpXG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vaHR0cGJpbi5vcmcvcG9zdFwiLCBvcHRpb25zKVxuICAgKlxuICAgKiBjb25zb2xlLmxvZyhhd2FpdCByZXNwb25zZS5qc29uKCkpXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgKmVuY29kZSgpIHtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGlzRmlsZShwYXJ0KSkge1xuICAgICAgICB5aWVsZCogZ2V0U3RyZWFtSXRlcmF0b3IocGFydC5zdHJlYW0oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCogY2h1bmsocGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGl0ZXJhdG9yIGFsbG93aW5nIHRvIHJlYWQgdGhyb3VnaCB0aGUgZW5jb2RlciBkYXRhIHVzaW5nIGZvci4uLm9mIGxvb3BzXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiAqKmFzeW5jKiogaXRlcmF0b3IgYWxsb3dpbmcgdG8gcmVhZCB0aHJvdWdoIHRoZSBlbmNvZGVyIGRhdGEgdXNpbmcgZm9yLWF3YWl0Li4ub2YgbG9vcHNcbiAgICovXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlKCk7XG4gIH1cbn07XG5fQ1JMRiA9IG5ldyBXZWFrTWFwKCk7XG5fQ1JMRl9CWVRFUyA9IG5ldyBXZWFrTWFwKCk7XG5fQ1JMRl9CWVRFU19MRU5HVEggPSBuZXcgV2Vha01hcCgpO1xuX0RBU0hFUyA9IG5ldyBXZWFrTWFwKCk7XG5fZW5jb2RlciA9IG5ldyBXZWFrTWFwKCk7XG5fZm9vdGVyID0gbmV3IFdlYWtNYXAoKTtcbl9mb3JtID0gbmV3IFdlYWtNYXAoKTtcbl9vcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcbl9Gb3JtRGF0YUVuY29kZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcbmdldEZpZWxkSGVhZGVyX2ZuID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgbGV0IGhlYWRlciA9IFwiXCI7XG4gIGhlYWRlciArPSBgJHtfX3ByaXZhdGVHZXQodGhpcywgX0RBU0hFUyl9JHt0aGlzLmJvdW5kYXJ5fSR7X19wcml2YXRlR2V0KHRoaXMsIF9DUkxGKX1gO1xuICBoZWFkZXIgKz0gYENvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIiR7ZXNjYXBlTmFtZShuYW1lKX1cImA7XG4gIGlmIChpc0ZpbGUodmFsdWUpKSB7XG4gICAgaGVhZGVyICs9IGA7IGZpbGVuYW1lPVwiJHtlc2NhcGVOYW1lKHZhbHVlLm5hbWUpfVwiJHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpfWA7XG4gICAgaGVhZGVyICs9IGBDb250ZW50LVR5cGU6ICR7dmFsdWUudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifWA7XG4gIH1cbiAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfb3B0aW9ucykuZW5hYmxlQWRkaXRpb25hbEhlYWRlcnMgPT09IHRydWUpIHtcbiAgICBjb25zdCBzaXplID0gaXNGaWxlKHZhbHVlKSA/IHZhbHVlLnNpemUgOiB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIGlmIChzaXplICE9IG51bGwgJiYgIWlzTmFOKHNpemUpKSB7XG4gICAgICBoZWFkZXIgKz0gYCR7X19wcml2YXRlR2V0KHRoaXMsIF9DUkxGKX1Db250ZW50LUxlbmd0aDogJHtzaXplfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2VuY29kZXIpLmVuY29kZShgJHtoZWFkZXJ9JHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpLnJlcGVhdCgyKX1gKTtcbn07XG4vKipcbiAqIFJldHVybnMgZm9ybS1kYXRhIGNvbnRlbnQgbGVuZ3RoXG4gKi9cbmdldENvbnRlbnRMZW5ndGhfZm4gPSBmdW5jdGlvbigpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGZvciAoY29uc3QgW25hbWUsIHJhd10gb2YgX19wcml2YXRlR2V0KHRoaXMsIF9mb3JtKSkge1xuICAgIGNvbnN0IHZhbHVlID0gaXNGaWxlKHJhdykgPyByYXcgOiBfX3ByaXZhdGVHZXQodGhpcywgX2VuY29kZXIpLmVuY29kZShub3JtYWxpemVWYWx1ZShyYXcpKTtcbiAgICBjb25zdCBzaXplID0gaXNGaWxlKHZhbHVlKSA/IHZhbHVlLnNpemUgOiB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIGlmIChzaXplID09IG51bGwgfHwgaXNOYU4oc2l6ZSkpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGxlbmd0aCArPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9pbnN0YW5jZXMsIGdldEZpZWxkSGVhZGVyX2ZuKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKS5ieXRlTGVuZ3RoO1xuICAgIGxlbmd0aCArPSBzaXplO1xuICAgIGxlbmd0aCArPSBfX3ByaXZhdGVHZXQodGhpcywgX0NSTEZfQllURVNfTEVOR1RIKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKGxlbmd0aCArIF9fcHJpdmF0ZUdldCh0aGlzLCBfZm9vdGVyKS5ieXRlTGVuZ3RoKTtcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRm9ybURhdGFFbmNvZGVyLFxuICBpc0ZpbGUsXG4gIGlzRm9ybURhdGFcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/form-data-encoder/lib/index.cjs\n");

/***/ })

};
;