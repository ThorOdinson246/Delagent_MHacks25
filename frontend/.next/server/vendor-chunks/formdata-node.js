"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/formdata-node";
exports.ids = ["vendor-chunks/formdata-node"];
exports.modules = {

/***/ "(rsc)/./node_modules/formdata-node/lib/form-data.cjs":
/*!******************************************************!*\
  !*** ./node_modules/formdata-node/lib/form-data.cjs ***!
  \******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Blob: () => Blob,\n  File: () => File,\n  FormData: () => FormData\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/isFunction.ts\nvar isFunction = (value) => typeof value === \"function\";\n\n// src/isObject.ts\nvar isObject = (value) => typeof value === \"object\" && value != null && !Array.isArray(value);\n\n// src/isAsyncIterable.ts\nvar isAsyncIterable = (value) => isObject(value) && isFunction(value[Symbol.asyncIterator]);\n\n// src/blobHelpers.ts\nvar MAX_CHUNK_SIZE = 65536;\nasync function* clonePart(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\nasync function* readStream(readable) {\n  const reader = readable.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function* chunkStream(stream) {\n  for await (const value of stream) {\n    yield* clonePart(value);\n  }\n}\nvar getStreamIterator = (source) => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isFunction(source.getReader)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\n    \"Unsupported data source: Expected either ReadableStream or async iterable.\"\n  );\n};\nasync function* consumeNodeBlob(blob) {\n  let position = 0;\n  while (position !== blob.size) {\n    const chunk = blob.slice(\n      position,\n      Math.min(blob.size, position + MAX_CHUNK_SIZE)\n    );\n    const buffer = await chunk.arrayBuffer();\n    position += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\nasync function* consumeBlobParts(parts, clone = false) {\n  for (const part of parts) {\n    if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        yield* clonePart(part);\n      } else {\n        yield part;\n      }\n    } else if (isFunction(part.stream)) {\n      yield* getStreamIterator(part.stream());\n    } else {\n      yield* consumeNodeBlob(part);\n    }\n  }\n}\nfunction* sliceBlob(blobParts, blobSize, start = 0, end) {\n  end ??= blobSize;\n  let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);\n  let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);\n  const span = Math.max(relativeEnd - relativeStart, 0);\n  let added = 0;\n  for (const part of blobParts) {\n    if (added >= span) {\n      break;\n    }\n    const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n    if (relativeStart && partSize <= relativeStart) {\n      relativeStart -= partSize;\n      relativeEnd -= partSize;\n    } else {\n      let chunk;\n      if (ArrayBuffer.isView(part)) {\n        chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));\n        added += chunk.byteLength;\n      } else {\n        chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));\n        added += chunk.size;\n      }\n      relativeEnd -= partSize;\n      relativeStart = 0;\n      yield chunk;\n    }\n  }\n}\n\n// src/Blob.ts\nvar _parts, _type, _size;\nvar _Blob = class _Blob {\n  /**\n   * Returns a new [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object.\n   * The content of the blob consists of the concatenation of the values given in the parameter array.\n   *\n   * @param blobParts An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n   * @param options An optional object of type `BlobPropertyBag`.\n   */\n  constructor(blobParts = [], options = {}) {\n    /**\n     * An `Array` of [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) or [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n     */\n    __privateAdd(this, _parts, []);\n    /**\n     * Returns the [`MIME type`](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type) of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n     */\n    __privateAdd(this, _type, \"\");\n    /**\n     * Returns the size of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) in bytes.\n     */\n    __privateAdd(this, _size, 0);\n    options ??= {};\n    if (typeof blobParts !== \"object\" || blobParts === null) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\"\n      );\n    }\n    if (!isFunction(blobParts[Symbol.iterator])) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': The object must have a callable @@iterator property.\"\n      );\n    }\n    if (typeof options !== \"object\" && !isFunction(options)) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\"\n      );\n    }\n    const encoder = new TextEncoder();\n    for (const raw of blobParts) {\n      let part;\n      if (ArrayBuffer.isView(raw)) {\n        part = new Uint8Array(raw.buffer.slice(\n          raw.byteOffset,\n          raw.byteOffset + raw.byteLength\n        ));\n      } else if (raw instanceof ArrayBuffer) {\n        part = new Uint8Array(raw.slice(0));\n      } else if (raw instanceof _Blob) {\n        part = raw;\n      } else {\n        part = encoder.encode(String(raw));\n      }\n      __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));\n      __privateGet(this, _parts).push(part);\n    }\n    const type = options.type === void 0 ? \"\" : String(options.type);\n    __privateSet(this, _type, /^[\\x20-\\x7E]*$/.test(type) ? type : \"\");\n  }\n  static [Symbol.hasInstance](value) {\n    return Boolean(\n      value && typeof value === \"object\" && isFunction(value.constructor) && (isFunction(value.stream) || isFunction(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n  }\n  /**\n   * Returns the [`MIME type`](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type) of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   */\n  get type() {\n    return __privateGet(this, _type);\n  }\n  /**\n   * Returns the size of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) in bytes.\n   */\n  get size() {\n    return __privateGet(this, _size);\n  }\n  /**\n   * Creates and returns a new [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object which contains data from a subset of the blob on which it's called.\n   *\n   * @param start An index into the Blob indicating the first byte to include in the new Blob. If you specify a negative value, it's treated as an offset from the end of the Blob toward the beginning. For example, -10 would be the 10th from last byte in the Blob. The default value is 0. If you specify a value for start that is larger than the size of the source Blob, the returned Blob has size 0 and contains no data.\n   * @param end An index into the Blob indicating the first byte that will *not* be included in the new Blob (i.e. the byte exactly at this index is not included). If you specify a negative value, it's treated as an offset from the end of the Blob toward the beginning. For example, -10 would be the 10th from last byte in the Blob. The default value is size.\n   * @param contentType The content type to assign to the new Blob; this will be the value of its type property. The default value is an empty string.\n   */\n  slice(start, end, contentType) {\n    return new _Blob(sliceBlob(__privateGet(this, _parts), this.size, start, end), {\n      type: contentType\n    });\n  }\n  /**\n   * Returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with a string containing the contents of the blob, interpreted as UTF-8.\n   */\n  async text() {\n    const decoder = new TextDecoder();\n    let result = \"\";\n    for await (const chunk of consumeBlobParts(__privateGet(this, _parts))) {\n      result += decoder.decode(chunk, { stream: true });\n    }\n    result += decoder.decode();\n    return result;\n  }\n  /**\n   * Returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with the contents of the blob as binary data contained in an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n   */\n  async arrayBuffer() {\n    const view = new Uint8Array(this.size);\n    let offset = 0;\n    for await (const chunk of consumeBlobParts(__privateGet(this, _parts))) {\n      view.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return view.buffer;\n  }\n  /**\n   * Returns a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) which upon reading returns the data contained within the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n   */\n  stream() {\n    const iterator = consumeBlobParts(__privateGet(this, _parts), true);\n    return new ReadableStream({\n      async pull(controller) {\n        const { value, done } = await iterator.next();\n        if (done) {\n          return queueMicrotask(() => controller.close());\n        }\n        controller.enqueue(value);\n      },\n      async cancel() {\n        await iterator.return();\n      }\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return \"Blob\";\n  }\n};\n_parts = new WeakMap();\n_type = new WeakMap();\n_size = new WeakMap();\nvar Blob = _Blob;\nObject.defineProperties(Blob.prototype, {\n  type: { enumerable: true },\n  size: { enumerable: true },\n  slice: { enumerable: true },\n  stream: { enumerable: true },\n  text: { enumerable: true },\n  arrayBuffer: { enumerable: true }\n});\n\n// src/isBlob.ts\nvar isBlob = (value) => value instanceof Blob;\n\n// src/File.ts\nvar _name, _lastModified;\nvar File = class extends Blob {\n  /**\n   * Creates a new File instance.\n   *\n   * @param fileBits An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   * @param name The name of the file.\n   * @param options An options object containing optional attributes for the file.\n   */\n  constructor(fileBits, name, options = {}) {\n    super(fileBits, options);\n    /**\n     * Returns the name of the file referenced by the File object.\n     */\n    __privateAdd(this, _name, void 0);\n    /**\n     * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.\n     */\n    __privateAdd(this, _lastModified, 0);\n    if (arguments.length < 2) {\n      throw new TypeError(\n        `Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`\n      );\n    }\n    __privateSet(this, _name, String(name));\n    const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);\n    if (!Number.isNaN(lastModified)) {\n      __privateSet(this, _lastModified, lastModified);\n    }\n  }\n  static [Symbol.hasInstance](value) {\n    return value instanceof Blob && value[Symbol.toStringTag] === \"File\" && typeof value.name === \"string\";\n  }\n  /**\n   * Name of the file referenced by the File object.\n   */\n  get name() {\n    return __privateGet(this, _name);\n  }\n  /* c8 ignore next 3 */\n  get webkitRelativePath() {\n    return \"\";\n  }\n  /**\n   * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.\n   */\n  get lastModified() {\n    return __privateGet(this, _lastModified);\n  }\n  get [Symbol.toStringTag]() {\n    return \"File\";\n  }\n};\n_name = new WeakMap();\n_lastModified = new WeakMap();\n\n// src/isFile.ts\nvar isFile = (value) => value instanceof File;\n\n// src/FormData.ts\nvar _entries, _setEntry, setEntry_fn;\nvar FormData = class {\n  constructor() {\n    __privateAdd(this, _setEntry);\n    /**\n     * Stores internal data for every entry\n     */\n    __privateAdd(this, _entries, /* @__PURE__ */ new Map());\n  }\n  static [Symbol.hasInstance](value) {\n    if (!value) {\n      return false;\n    }\n    const val = value;\n    return Boolean(\n      isFunction(val.constructor) && val[Symbol.toStringTag] === \"FormData\" && isFunction(val.append) && isFunction(val.set) && isFunction(val.get) && isFunction(val.getAll) && isFunction(val.has) && isFunction(val.delete) && isFunction(val.entries) && isFunction(val.values) && isFunction(val.keys) && isFunction(val[Symbol.iterator]) && isFunction(val.forEach)\n    );\n  }\n  /**\n   * Appends a new value onto an existing key inside a FormData object,\n   * or adds the key if it does not already exist.\n   *\n   * The difference between `set()` and `append()` is that if the specified key already exists, `set()` will overwrite all existing values with the new one, whereas `append()` will append the new value onto the end of the existing set of values.\n   *\n   * @param name The name of the field whose data is contained in `value`.\n   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.\n   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is \"blob\". The default filename for File objects is the file's filename.\n   */\n  append(name, value, fileName) {\n    __privateMethod(this, _setEntry, setEntry_fn).call(this, {\n      name,\n      fileName,\n      append: true,\n      rawValue: value,\n      argsLength: arguments.length\n    });\n  }\n  /**\n   * Set a new value for an existing key inside FormData,\n   * or add the new field if it does not already exist.\n   *\n   * @param name The name of the field whose data is contained in `value`.\n   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.\n   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is \"blob\". The default filename for File objects is the file's filename.\n   *\n   */\n  set(name, value, fileName) {\n    __privateMethod(this, _setEntry, setEntry_fn).call(this, {\n      name,\n      fileName,\n      append: false,\n      rawValue: value,\n      argsLength: arguments.length\n    });\n  }\n  /**\n   * Returns the first value associated with a given key from within a `FormData` object.\n   * If you expect multiple values and want all of them, use the `getAll()` method instead.\n   *\n   * @param {string} name A name of the value you want to retrieve.\n   *\n   * @returns A `FormDataEntryValue` containing the value. If the key doesn't exist, the method returns null.\n   */\n  get(name) {\n    const field = __privateGet(this, _entries).get(String(name));\n    if (!field) {\n      return null;\n    }\n    return field[0];\n  }\n  /**\n   * Returns all the values associated with a given key from within a `FormData` object.\n   *\n   * @param {string} name A name of the value you want to retrieve.\n   *\n   * @returns An array of `FormDataEntryValue` whose key matches the value passed in the `name` parameter. If the key doesn't exist, the method returns an empty list.\n   */\n  getAll(name) {\n    const field = __privateGet(this, _entries).get(String(name));\n    if (!field) {\n      return [];\n    }\n    return field.slice();\n  }\n  /**\n   * Returns a boolean stating whether a `FormData` object contains a certain key.\n   *\n   * @param name A string representing the name of the key you want to test for.\n   *\n   * @return A boolean value.\n   */\n  has(name) {\n    return __privateGet(this, _entries).has(String(name));\n  }\n  /**\n   * Deletes a key and its value(s) from a `FormData` object.\n   *\n   * @param name The name of the key you want to delete.\n   */\n  delete(name) {\n    __privateGet(this, _entries).delete(String(name));\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all keys contained in this `FormData` object.\n   * Each key is a `string`.\n   */\n  *keys() {\n    for (const key of __privateGet(this, _entries).keys()) {\n      yield key;\n    }\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through the `FormData` key/value pairs.\n   * The key of each pair is a string; the value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).\n   */\n  *entries() {\n    for (const name of this.keys()) {\n      const values = this.getAll(name);\n      for (const value of values) {\n        yield [name, value];\n      }\n    }\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all values contained in this object `FormData` object.\n   * Each value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).\n   */\n  *values() {\n    for (const [, value] of this) {\n      yield value;\n    }\n  }\n  /**\n   * An alias for FormData#entries()\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Executes given callback function for each field of the FormData instance\n   */\n  forEach(callback, thisArg) {\n    for (const [name, value] of this) {\n      callback.call(thisArg, value, name, this);\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"FormData\";\n  }\n};\n_entries = new WeakMap();\n_setEntry = new WeakSet();\nsetEntry_fn = function({\n  name,\n  rawValue,\n  append,\n  fileName,\n  argsLength\n}) {\n  const methodName = append ? \"append\" : \"set\";\n  if (argsLength < 2) {\n    throw new TypeError(\n      `Failed to execute '${methodName}' on 'FormData': 2 arguments required, but only ${argsLength} present.`\n    );\n  }\n  name = String(name);\n  let value;\n  if (isFile(rawValue)) {\n    value = fileName === void 0 ? rawValue : new File([rawValue], fileName, {\n      // otherwise, create new File with given fileName\n      type: rawValue.type,\n      lastModified: rawValue.lastModified\n    });\n  } else if (isBlob(rawValue)) {\n    value = new File([rawValue], fileName === void 0 ? \"blob\" : fileName, {\n      type: rawValue.type\n    });\n  } else if (fileName) {\n    throw new TypeError(\n      `Failed to execute '${methodName}' on 'FormData': parameter 2 is not of type 'Blob'.`\n    );\n  } else {\n    value = String(rawValue);\n  }\n  const values = __privateGet(this, _entries).get(name);\n  if (!values) {\n    return void __privateGet(this, _entries).set(name, [value]);\n  }\n  if (!append) {\n    return void __privateGet(this, _entries).set(name, [value]);\n  }\n  values.push(value);\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9ybWRhdGEtbm9kZS9saWIvZm9ybS1kYXRhLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxrQkFBa0I7QUFDNUIsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxrQkFBa0I7QUFDOUIsVUFBVSxrQkFBa0I7QUFDNUIsaUJBQWlCO0FBQ2pCLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxrREFBa0QsWUFBWTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2Zvcm1kYXRhLW5vZGUvbGliL2Zvcm0tZGF0YS5janM/YzU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBCbG9iOiAoKSA9PiBCbG9iLFxuICBGaWxlOiAoKSA9PiBGaWxlLFxuICBGb3JtRGF0YTogKCkgPT4gRm9ybURhdGFcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvaXNGdW5jdGlvbi50c1xudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4vLyBzcmMvaXNPYmplY3QudHNcbnZhciBpc09iamVjdCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4vLyBzcmMvaXNBc3luY0l0ZXJhYmxlLnRzXG52YXIgaXNBc3luY0l0ZXJhYmxlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pO1xuXG4vLyBzcmMvYmxvYkhlbHBlcnMudHNcbnZhciBNQVhfQ0hVTktfU0laRSA9IDY1NTM2O1xuYXN5bmMgZnVuY3Rpb24qIGNsb25lUGFydCh2YWx1ZSkge1xuICBpZiAodmFsdWUuYnl0ZUxlbmd0aCA8PSBNQVhfQ0hVTktfU0laRSkge1xuICAgIHlpZWxkIHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgd2hpbGUgKG9mZnNldCA8IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4odmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldCwgTUFYX0NIVU5LX1NJWkUpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IHZhbHVlLmJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgIG9mZnNldCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB5aWVsZCBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZFN0cmVhbShyZWFkYWJsZSkge1xuICBjb25zdCByZWFkZXIgPSByZWFkYWJsZS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgeWllbGQgdmFsdWU7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBjaHVua1N0cmVhbShzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJlYW0pIHtcbiAgICB5aWVsZCogY2xvbmVQYXJ0KHZhbHVlKTtcbiAgfVxufVxudmFyIGdldFN0cmVhbUl0ZXJhdG9yID0gKHNvdXJjZSkgPT4ge1xuICBpZiAoaXNBc3luY0l0ZXJhYmxlKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gY2h1bmtTdHJlYW0oc291cmNlKTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UuZ2V0UmVhZGVyKSkge1xuICAgIHJldHVybiBjaHVua1N0cmVhbShyZWFkU3RyZWFtKHNvdXJjZSkpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgXCJVbnN1cHBvcnRlZCBkYXRhIHNvdXJjZTogRXhwZWN0ZWQgZWl0aGVyIFJlYWRhYmxlU3RyZWFtIG9yIGFzeW5jIGl0ZXJhYmxlLlwiXG4gICk7XG59O1xuYXN5bmMgZnVuY3Rpb24qIGNvbnN1bWVOb2RlQmxvYihibG9iKSB7XG4gIGxldCBwb3NpdGlvbiA9IDA7XG4gIHdoaWxlIChwb3NpdGlvbiAhPT0gYmxvYi5zaXplKSB7XG4gICAgY29uc3QgY2h1bmsgPSBibG9iLnNsaWNlKFxuICAgICAgcG9zaXRpb24sXG4gICAgICBNYXRoLm1pbihibG9iLnNpemUsIHBvc2l0aW9uICsgTUFYX0NIVU5LX1NJWkUpXG4gICAgKTtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpO1xuICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBjb25zdW1lQmxvYlBhcnRzKHBhcnRzLCBjbG9uZSA9IGZhbHNlKSB7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgIGlmIChjbG9uZSkge1xuICAgICAgICB5aWVsZCogY2xvbmVQYXJ0KHBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgcGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocGFydC5zdHJlYW0pKSB7XG4gICAgICB5aWVsZCogZ2V0U3RyZWFtSXRlcmF0b3IocGFydC5zdHJlYW0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlpZWxkKiBjb25zdW1lTm9kZUJsb2IocGFydCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiogc2xpY2VCbG9iKGJsb2JQYXJ0cywgYmxvYlNpemUsIHN0YXJ0ID0gMCwgZW5kKSB7XG4gIGVuZCA/Pz0gYmxvYlNpemU7XG4gIGxldCByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPCAwID8gTWF0aC5tYXgoYmxvYlNpemUgKyBzdGFydCwgMCkgOiBNYXRoLm1pbihzdGFydCwgYmxvYlNpemUpO1xuICBsZXQgcmVsYXRpdmVFbmQgPSBlbmQgPCAwID8gTWF0aC5tYXgoYmxvYlNpemUgKyBlbmQsIDApIDogTWF0aC5taW4oZW5kLCBibG9iU2l6ZSk7XG4gIGNvbnN0IHNwYW4gPSBNYXRoLm1heChyZWxhdGl2ZUVuZCAtIHJlbGF0aXZlU3RhcnQsIDApO1xuICBsZXQgYWRkZWQgPSAwO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgaWYgKGFkZGVkID49IHNwYW4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0U2l6ZSA9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZTtcbiAgICBpZiAocmVsYXRpdmVTdGFydCAmJiBwYXJ0U2l6ZSA8PSByZWxhdGl2ZVN0YXJ0KSB7XG4gICAgICByZWxhdGl2ZVN0YXJ0IC09IHBhcnRTaXplO1xuICAgICAgcmVsYXRpdmVFbmQgLT0gcGFydFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjaHVuaztcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgICAgY2h1bmsgPSBwYXJ0LnN1YmFycmF5KHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHBhcnRTaXplLCByZWxhdGl2ZUVuZCkpO1xuICAgICAgICBhZGRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsgPSBwYXJ0LnNsaWNlKHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHBhcnRTaXplLCByZWxhdGl2ZUVuZCkpO1xuICAgICAgICBhZGRlZCArPSBjaHVuay5zaXplO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmVFbmQgLT0gcGFydFNpemU7XG4gICAgICByZWxhdGl2ZVN0YXJ0ID0gMDtcbiAgICAgIHlpZWxkIGNodW5rO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvQmxvYi50c1xudmFyIF9wYXJ0cywgX3R5cGUsIF9zaXplO1xudmFyIF9CbG9iID0gY2xhc3MgX0Jsb2Ige1xuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb2JqZWN0LlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgYmxvYiBjb25zaXN0cyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdmFsdWVzIGdpdmVuIGluIHRoZSBwYXJhbWV0ZXIgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSBibG9iUGFydHMgQW4gYEFycmF5YCBzdHJpbmdzLCBvciBbYEFycmF5QnVmZmVyYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXIpLCBbYEFycmF5QnVmZmVyVmlld2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BcnJheUJ1ZmZlclZpZXcpLCBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb2JqZWN0cywgb3IgYSBtaXggb2YgYW55IG9mIHN1Y2ggb2JqZWN0cywgdGhhdCB3aWxsIGJlIHB1dCBpbnNpZGUgdGhlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKS5cbiAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9uYWwgb2JqZWN0IG9mIHR5cGUgYEJsb2JQcm9wZXJ0eUJhZ2AuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihibG9iUGFydHMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogQW4gYEFycmF5YCBvZiBbYEFycmF5QnVmZmVyVmlld2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BcnJheUJ1ZmZlclZpZXcpIG9yIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvYmplY3RzLCBvciBhIG1peCBvZiBhbnkgb2Ygc3VjaCBvYmplY3RzLCB0aGF0IHdpbGwgYmUgcHV0IGluc2lkZSB0aGUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpLlxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcGFydHMsIFtdKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBbYE1JTUUgdHlwZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvTUlNRV90eXBlKSBvZiB0aGUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9yIFtgRmlsZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS5cbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3R5cGUsIFwiXCIpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvciBbYEZpbGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zaXplLCAwKTtcbiAgICBvcHRpb25zID8/PSB7fTtcbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0cyAhPT0gXCJvYmplY3RcIiB8fCBibG9iUGFydHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnQmxvYic6IFRoZSBwcm92aWRlZCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgc2VxdWVuY2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNGdW5jdGlvbihibG9iUGFydHNbU3ltYm9sLml0ZXJhdG9yXSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnQmxvYic6IFRoZSBvYmplY3QgbXVzdCBoYXZlIGEgY2FsbGFibGUgQEBpdGVyYXRvciBwcm9wZXJ0eS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Jsb2InOiBwYXJhbWV0ZXIgMiBjYW5ub3QgY29udmVydCB0byBkaWN0aW9uYXJ5LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgZm9yIChjb25zdCByYXcgb2YgYmxvYlBhcnRzKSB7XG4gICAgICBsZXQgcGFydDtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocmF3KSkge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkocmF3LmJ1ZmZlci5zbGljZShcbiAgICAgICAgICByYXcuYnl0ZU9mZnNldCxcbiAgICAgICAgICByYXcuYnl0ZU9mZnNldCArIHJhdy5ieXRlTGVuZ3RoXG4gICAgICAgICkpO1xuICAgICAgfSBlbHNlIGlmIChyYXcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkocmF3LnNsaWNlKDApKTtcbiAgICAgIH0gZWxzZSBpZiAocmF3IGluc3RhbmNlb2YgX0Jsb2IpIHtcbiAgICAgICAgcGFydCA9IHJhdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBlbmNvZGVyLmVuY29kZShTdHJpbmcocmF3KSk7XG4gICAgICB9XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NpemUsIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2l6ZSkgKyAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpID8gcGFydC5ieXRlTGVuZ3RoIDogcGFydC5zaXplKSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3BhcnRzKS5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlID09PSB2b2lkIDAgPyBcIlwiIDogU3RyaW5nKG9wdGlvbnMudHlwZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90eXBlLCAvXltcXHgyMC1cXHg3RV0qJC8udGVzdCh0eXBlKSA/IHR5cGUgOiBcIlwiKTtcbiAgfVxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0odmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpc0Z1bmN0aW9uKHZhbHVlLmNvbnN0cnVjdG9yKSAmJiAoaXNGdW5jdGlvbih2YWx1ZS5zdHJlYW0pIHx8IGlzRnVuY3Rpb24odmFsdWUuYXJyYXlCdWZmZXIpKSAmJiAvXihCbG9ifEZpbGUpJC8udGVzdCh2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFtgTUlNRSB0eXBlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9NSU1FX3R5cGUpIG9mIHRoZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb3IgW2BGaWxlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLlxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvciBbYEZpbGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkgaW4gYnl0ZXMuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zaXplKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGRhdGEgZnJvbSBhIHN1YnNldCBvZiB0aGUgYmxvYiBvbiB3aGljaCBpdCdzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0IEFuIGluZGV4IGludG8gdGhlIEJsb2IgaW5kaWNhdGluZyB0aGUgZmlyc3QgYnl0ZSB0byBpbmNsdWRlIGluIHRoZSBuZXcgQmxvYi4gSWYgeW91IHNwZWNpZnkgYSBuZWdhdGl2ZSB2YWx1ZSwgaXQncyB0cmVhdGVkIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIEJsb2IgdG93YXJkIHRoZSBiZWdpbm5pbmcuIEZvciBleGFtcGxlLCAtMTAgd291bGQgYmUgdGhlIDEwdGggZnJvbSBsYXN0IGJ5dGUgaW4gdGhlIEJsb2IuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuIElmIHlvdSBzcGVjaWZ5IGEgdmFsdWUgZm9yIHN0YXJ0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlIHNpemUgb2YgdGhlIHNvdXJjZSBCbG9iLCB0aGUgcmV0dXJuZWQgQmxvYiBoYXMgc2l6ZSAwIGFuZCBjb250YWlucyBubyBkYXRhLlxuICAgKiBAcGFyYW0gZW5kIEFuIGluZGV4IGludG8gdGhlIEJsb2IgaW5kaWNhdGluZyB0aGUgZmlyc3QgYnl0ZSB0aGF0IHdpbGwgKm5vdCogYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBCbG9iIChpLmUuIHRoZSBieXRlIGV4YWN0bHkgYXQgdGhpcyBpbmRleCBpcyBub3QgaW5jbHVkZWQpLiBJZiB5b3Ugc3BlY2lmeSBhIG5lZ2F0aXZlIHZhbHVlLCBpdCdzIHRyZWF0ZWQgYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgQmxvYiB0b3dhcmQgdGhlIGJlZ2lubmluZy4gRm9yIGV4YW1wbGUsIC0xMCB3b3VsZCBiZSB0aGUgMTB0aCBmcm9tIGxhc3QgYnl0ZSBpbiB0aGUgQmxvYi4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgc2l6ZS5cbiAgICogQHBhcmFtIGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgdG8gYXNzaWduIHRvIHRoZSBuZXcgQmxvYjsgdGhpcyB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBpdHMgdHlwZSBwcm9wZXJ0eS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cbiAgc2xpY2Uoc3RhcnQsIGVuZCwgY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IF9CbG9iKHNsaWNlQmxvYihfX3ByaXZhdGVHZXQodGhpcywgX3BhcnRzKSwgdGhpcy5zaXplLCBzdGFydCwgZW5kKSwge1xuICAgICAgdHlwZTogY29udGVudFR5cGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIFtgUHJvbWlzZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UpIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZiB0aGUgYmxvYiwgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gICAqL1xuICBhc3luYyB0ZXh0KCkge1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCbG9iUGFydHMoX19wcml2YXRlR2V0KHRoaXMsIF9wYXJ0cykpKSB7XG4gICAgICByZXN1bHQgKz0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXN1bHQgKz0gZGVjb2Rlci5kZWNvZGUoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgW2BQcm9taXNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZSkgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgYmxvYiBhcyBiaW5hcnkgZGF0YSBjb250YWluZWQgaW4gYW4gW2BBcnJheUJ1ZmZlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5QnVmZmVyKS5cbiAgICovXG4gIGFzeW5jIGFycmF5QnVmZmVyKCkge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUJsb2JQYXJ0cyhfX3ByaXZhdGVHZXQodGhpcywgX3BhcnRzKSkpIHtcbiAgICAgIHZpZXcuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgW2BSZWFkYWJsZVN0cmVhbWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZWFkYWJsZVN0cmVhbSkgd2hpY2ggdXBvbiByZWFkaW5nIHJldHVybnMgdGhlIGRhdGEgY29udGFpbmVkIHdpdGhpbiB0aGUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpLlxuICAgKi9cbiAgc3RyZWFtKCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gY29uc3VtZUJsb2JQYXJ0cyhfX3ByaXZhdGVHZXQodGhpcywgX3BhcnRzKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHJldHVybiBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjb250cm9sbGVyLmNsb3NlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiQmxvYlwiO1xuICB9XG59O1xuX3BhcnRzID0gbmV3IFdlYWtNYXAoKTtcbl90eXBlID0gbmV3IFdlYWtNYXAoKTtcbl9zaXplID0gbmV3IFdlYWtNYXAoKTtcbnZhciBCbG9iID0gX0Jsb2I7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbG9iLnByb3RvdHlwZSwge1xuICB0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNsaWNlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc3RyZWFtOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdGV4dDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGFycmF5QnVmZmVyOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbi8vIHNyYy9pc0Jsb2IudHNcbnZhciBpc0Jsb2IgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgQmxvYjtcblxuLy8gc3JjL0ZpbGUudHNcbnZhciBfbmFtZSwgX2xhc3RNb2RpZmllZDtcbnZhciBGaWxlID0gY2xhc3MgZXh0ZW5kcyBCbG9iIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRmlsZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIGZpbGVCaXRzIEFuIGBBcnJheWAgc3RyaW5ncywgb3IgW2BBcnJheUJ1ZmZlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5QnVmZmVyKSwgW2BBcnJheUJ1ZmZlclZpZXdgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXJyYXlCdWZmZXJWaWV3KSwgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9iamVjdHMsIG9yIGEgbWl4IG9mIGFueSBvZiBzdWNoIG9iamVjdHMsIHRoYXQgd2lsbCBiZSBwdXQgaW5zaWRlIHRoZSBbYEZpbGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIGF0dHJpYnV0ZXMgZm9yIHRoZSBmaWxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsZUJpdHMsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGZpbGVCaXRzLCBvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHJlZmVyZW5jZWQgYnkgdGhlIEZpbGUgb2JqZWN0LlxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbmFtZSwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBtb2RpZmllZCBkYXRlIG9mIHRoZSBmaWxlIGFzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoIChKYW51YXJ5IDEsIDE5NzAgYXQgbWlkbmlnaHQpLiBGaWxlcyB3aXRob3V0IGEga25vd24gbGFzdCBtb2RpZmllZCBkYXRlIHJldHVybiB0aGUgY3VycmVudCBkYXRlLlxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGFzdE1vZGlmaWVkLCAwKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gY29uc3RydWN0ICdGaWxlJzogMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJndW1lbnRzLmxlbmd0aH0gcHJlc2VudC5gXG4gICAgICApO1xuICAgIH1cbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX25hbWUsIFN0cmluZyhuYW1lKSk7XG4gICAgY29uc3QgbGFzdE1vZGlmaWVkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgPT09IHZvaWQgMCA/IERhdGUubm93KCkgOiBOdW1iZXIob3B0aW9ucy5sYXN0TW9kaWZpZWQpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKGxhc3RNb2RpZmllZCkpIHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGFzdE1vZGlmaWVkLCBsYXN0TW9kaWZpZWQpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBCbG9iICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiRmlsZVwiICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBmaWxlIHJlZmVyZW5jZWQgYnkgdGhlIEZpbGUgb2JqZWN0LlxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbmFtZSk7XG4gIH1cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBnZXQgd2Via2l0UmVsYXRpdmVQYXRoKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBtb2RpZmllZCBkYXRlIG9mIHRoZSBmaWxlIGFzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoIChKYW51YXJ5IDEsIDE5NzAgYXQgbWlkbmlnaHQpLiBGaWxlcyB3aXRob3V0IGEga25vd24gbGFzdCBtb2RpZmllZCBkYXRlIHJldHVybiB0aGUgY3VycmVudCBkYXRlLlxuICAgKi9cbiAgZ2V0IGxhc3RNb2RpZmllZCgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9sYXN0TW9kaWZpZWQpO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJGaWxlXCI7XG4gIH1cbn07XG5fbmFtZSA9IG5ldyBXZWFrTWFwKCk7XG5fbGFzdE1vZGlmaWVkID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gc3JjL2lzRmlsZS50c1xudmFyIGlzRmlsZSA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBGaWxlO1xuXG4vLyBzcmMvRm9ybURhdGEudHNcbnZhciBfZW50cmllcywgX3NldEVudHJ5LCBzZXRFbnRyeV9mbjtcbnZhciBGb3JtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXRFbnRyeSk7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIGludGVybmFsIGRhdGEgZm9yIGV2ZXJ5IGVudHJ5XG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9lbnRyaWVzLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0odmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IHZhbHVlO1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IpICYmIHZhbFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIkZvcm1EYXRhXCIgJiYgaXNGdW5jdGlvbih2YWwuYXBwZW5kKSAmJiBpc0Z1bmN0aW9uKHZhbC5zZXQpICYmIGlzRnVuY3Rpb24odmFsLmdldCkgJiYgaXNGdW5jdGlvbih2YWwuZ2V0QWxsKSAmJiBpc0Z1bmN0aW9uKHZhbC5oYXMpICYmIGlzRnVuY3Rpb24odmFsLmRlbGV0ZSkgJiYgaXNGdW5jdGlvbih2YWwuZW50cmllcykgJiYgaXNGdW5jdGlvbih2YWwudmFsdWVzKSAmJiBpc0Z1bmN0aW9uKHZhbC5rZXlzKSAmJiBpc0Z1bmN0aW9uKHZhbFtTeW1ib2wuaXRlcmF0b3JdKSAmJiBpc0Z1bmN0aW9uKHZhbC5mb3JFYWNoKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgYSBuZXcgdmFsdWUgb250byBhbiBleGlzdGluZyBrZXkgaW5zaWRlIGEgRm9ybURhdGEgb2JqZWN0LFxuICAgKiBvciBhZGRzIHRoZSBrZXkgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBgc2V0KClgIGFuZCBgYXBwZW5kKClgIGlzIHRoYXQgaWYgdGhlIHNwZWNpZmllZCBrZXkgYWxyZWFkeSBleGlzdHMsIGBzZXQoKWAgd2lsbCBvdmVyd3JpdGUgYWxsIGV4aXN0aW5nIHZhbHVlcyB3aXRoIHRoZSBuZXcgb25lLCB3aGVyZWFzIGBhcHBlbmQoKWAgd2lsbCBhcHBlbmQgdGhlIG5ldyB2YWx1ZSBvbnRvIHRoZSBlbmQgb2YgdGhlIGV4aXN0aW5nIHNldCBvZiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB3aG9zZSBkYXRhIGlzIGNvbnRhaW5lZCBpbiBgdmFsdWVgLlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIGZpZWxkJ3MgdmFsdWUuIFRoaXMgY2FuIGJlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKVxuICAgIG9yIFtgRmlsZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS4gSWYgbm9uZSBvZiB0aGVzZSBhcmUgc3BlY2lmaWVkIHRoZSB2YWx1ZSBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSBmaWxlTmFtZSBUaGUgZmlsZW5hbWUgcmVwb3J0ZWQgdG8gdGhlIHNlcnZlciwgd2hlbiBhIEJsb2Igb3IgRmlsZSBpcyBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuIFRoZSBkZWZhdWx0IGZpbGVuYW1lIGZvciBCbG9iIG9iamVjdHMgaXMgXCJibG9iXCIuIFRoZSBkZWZhdWx0IGZpbGVuYW1lIGZvciBGaWxlIG9iamVjdHMgaXMgdGhlIGZpbGUncyBmaWxlbmFtZS5cbiAgICovXG4gIGFwcGVuZChuYW1lLCB2YWx1ZSwgZmlsZU5hbWUpIHtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NldEVudHJ5LCBzZXRFbnRyeV9mbikuY2FsbCh0aGlzLCB7XG4gICAgICBuYW1lLFxuICAgICAgZmlsZU5hbWUsXG4gICAgICBhcHBlbmQ6IHRydWUsXG4gICAgICByYXdWYWx1ZTogdmFsdWUsXG4gICAgICBhcmdzTGVuZ3RoOiBhcmd1bWVudHMubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIG5ldyB2YWx1ZSBmb3IgYW4gZXhpc3Rpbmcga2V5IGluc2lkZSBGb3JtRGF0YSxcbiAgICogb3IgYWRkIHRoZSBuZXcgZmllbGQgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHdob3NlIGRhdGEgaXMgY29udGFpbmVkIGluIGB2YWx1ZWAuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgZmllbGQncyB2YWx1ZS4gVGhpcyBjYW4gYmUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpXG4gICAgb3IgW2BGaWxlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLiBJZiBub25lIG9mIHRoZXNlIGFyZSBzcGVjaWZpZWQgdGhlIHZhbHVlIGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZy5cbiAgICogQHBhcmFtIGZpbGVOYW1lIFRoZSBmaWxlbmFtZSByZXBvcnRlZCB0byB0aGUgc2VydmVyLCB3aGVuIGEgQmxvYiBvciBGaWxlIGlzIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIEJsb2Igb2JqZWN0cyBpcyBcImJsb2JcIi4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIEZpbGUgb2JqZWN0cyBpcyB0aGUgZmlsZSdzIGZpbGVuYW1lLlxuICAgKlxuICAgKi9cbiAgc2V0KG5hbWUsIHZhbHVlLCBmaWxlTmFtZSkge1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfc2V0RW50cnksIHNldEVudHJ5X2ZuKS5jYWxsKHRoaXMsIHtcbiAgICAgIG5hbWUsXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGFwcGVuZDogZmFsc2UsXG4gICAgICByYXdWYWx1ZTogdmFsdWUsXG4gICAgICBhcmdzTGVuZ3RoOiBhcmd1bWVudHMubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGtleSBmcm9tIHdpdGhpbiBhIGBGb3JtRGF0YWAgb2JqZWN0LlxuICAgKiBJZiB5b3UgZXhwZWN0IG11bHRpcGxlIHZhbHVlcyBhbmQgd2FudCBhbGwgb2YgdGhlbSwgdXNlIHRoZSBgZ2V0QWxsKClgIG1ldGhvZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIG5hbWUgb2YgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGBGb3JtRGF0YUVudHJ5VmFsdWVgIGNvbnRhaW5pbmcgdGhlIHZhbHVlLiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3QsIHRoZSBtZXRob2QgcmV0dXJucyBudWxsLlxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBjb25zdCBmaWVsZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykuZ2V0KFN0cmluZyhuYW1lKSk7XG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZFswXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBrZXkgZnJvbSB3aXRoaW4gYSBgRm9ybURhdGFgIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBuYW1lIG9mIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYEZvcm1EYXRhRW50cnlWYWx1ZWAgd2hvc2Uga2V5IG1hdGNoZXMgdGhlIHZhbHVlIHBhc3NlZCBpbiB0aGUgYG5hbWVgIHBhcmFtZXRlci4gSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0LCB0aGUgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgbGlzdC5cbiAgICovXG4gIGdldEFsbChuYW1lKSB7XG4gICAgY29uc3QgZmllbGQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLmdldChTdHJpbmcobmFtZSkpO1xuICAgIGlmICghZmllbGQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLnNsaWNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIHN0YXRpbmcgd2hldGhlciBhIGBGb3JtRGF0YWAgb2JqZWN0IGNvbnRhaW5zIGEgY2VydGFpbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUga2V5IHlvdSB3YW50IHRvIHRlc3QgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIEEgYm9vbGVhbiB2YWx1ZS5cbiAgICovXG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykuaGFzKFN0cmluZyhuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBrZXkgYW5kIGl0cyB2YWx1ZShzKSBmcm9tIGEgYEZvcm1EYXRhYCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkgeW91IHdhbnQgdG8gZGVsZXRlLlxuICAgKi9cbiAgZGVsZXRlKG5hbWUpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLmRlbGV0ZShTdHJpbmcobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFtgaXRlcmF0b3JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzKSBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGFsbCBrZXlzIGNvbnRhaW5lZCBpbiB0aGlzIGBGb3JtRGF0YWAgb2JqZWN0LlxuICAgKiBFYWNoIGtleSBpcyBhIGBzdHJpbmdgLlxuICAgKi9cbiAgKmtleXMoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5rZXlzKCkpIHtcbiAgICAgIHlpZWxkIGtleTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gW2BpdGVyYXRvcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHMpIGFsbG93aW5nIHRvIGdvIHRocm91Z2ggdGhlIGBGb3JtRGF0YWAga2V5L3ZhbHVlIHBhaXJzLlxuICAgKiBUaGUga2V5IG9mIGVhY2ggcGFpciBpcyBhIHN0cmluZzsgdGhlIHZhbHVlIGlzIGEgW2BGb3JtRGF0YVZhbHVlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Zvcm1EYXRhRW50cnlWYWx1ZSkuXG4gICAqL1xuICAqZW50cmllcygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKG5hbWUpO1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgeWllbGQgW25hbWUsIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gW2BpdGVyYXRvcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHMpIGFsbG93aW5nIHRvIGdvIHRocm91Z2ggYWxsIHZhbHVlcyBjb250YWluZWQgaW4gdGhpcyBvYmplY3QgYEZvcm1EYXRhYCBvYmplY3QuXG4gICAqIEVhY2ggdmFsdWUgaXMgYSBbYEZvcm1EYXRhVmFsdWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRm9ybURhdGFFbnRyeVZhbHVlKS5cbiAgICovXG4gICp2YWx1ZXMoKSB7XG4gICAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3IgRm9ybURhdGEjZW50cmllcygpXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGZpZWxkIG9mIHRoZSBGb3JtRGF0YSBpbnN0YW5jZVxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkZvcm1EYXRhXCI7XG4gIH1cbn07XG5fZW50cmllcyA9IG5ldyBXZWFrTWFwKCk7XG5fc2V0RW50cnkgPSBuZXcgV2Vha1NldCgpO1xuc2V0RW50cnlfZm4gPSBmdW5jdGlvbih7XG4gIG5hbWUsXG4gIHJhd1ZhbHVlLFxuICBhcHBlbmQsXG4gIGZpbGVOYW1lLFxuICBhcmdzTGVuZ3RoXG59KSB7XG4gIGNvbnN0IG1ldGhvZE5hbWUgPSBhcHBlbmQgPyBcImFwcGVuZFwiIDogXCJzZXRcIjtcbiAgaWYgKGFyZ3NMZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHttZXRob2ROYW1lfScgb24gJ0Zvcm1EYXRhJzogMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJnc0xlbmd0aH0gcHJlc2VudC5gXG4gICAgKTtcbiAgfVxuICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICBsZXQgdmFsdWU7XG4gIGlmIChpc0ZpbGUocmF3VmFsdWUpKSB7XG4gICAgdmFsdWUgPSBmaWxlTmFtZSA9PT0gdm9pZCAwID8gcmF3VmFsdWUgOiBuZXcgRmlsZShbcmF3VmFsdWVdLCBmaWxlTmFtZSwge1xuICAgICAgLy8gb3RoZXJ3aXNlLCBjcmVhdGUgbmV3IEZpbGUgd2l0aCBnaXZlbiBmaWxlTmFtZVxuICAgICAgdHlwZTogcmF3VmFsdWUudHlwZSxcbiAgICAgIGxhc3RNb2RpZmllZDogcmF3VmFsdWUubGFzdE1vZGlmaWVkXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNCbG9iKHJhd1ZhbHVlKSkge1xuICAgIHZhbHVlID0gbmV3IEZpbGUoW3Jhd1ZhbHVlXSwgZmlsZU5hbWUgPT09IHZvaWQgMCA/IFwiYmxvYlwiIDogZmlsZU5hbWUsIHtcbiAgICAgIHR5cGU6IHJhd1ZhbHVlLnR5cGVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChmaWxlTmFtZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bWV0aG9kTmFtZX0nIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJy5gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IFN0cmluZyhyYXdWYWx1ZSk7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5nZXQobmFtZSk7XG4gIGlmICghdmFsdWVzKSB7XG4gICAgcmV0dXJuIHZvaWQgX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5zZXQobmFtZSwgW3ZhbHVlXSk7XG4gIH1cbiAgaWYgKCFhcHBlbmQpIHtcbiAgICByZXR1cm4gdm9pZCBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLnNldChuYW1lLCBbdmFsdWVdKTtcbiAgfVxuICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG59O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJsb2IsXG4gIEZpbGUsXG4gIEZvcm1EYXRhXG59KTtcbi8qISBCYXNlZCBvbiBmZXRjaC1ibG9iLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAmIERhdmlkIEZyYW5rICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/formdata-node/lib/form-data.cjs\n");

/***/ })

};
;